---
phase: 01-token-management-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/app/auth/router.py
  - backend/app/auth/token_refresh.py
autonomous: true

must_haves:
  truths:
    - "New users authenticating get access and refresh tokens stored encrypted in database"
    - "Existing users can grant Drive scopes via incremental authorization (/auth/login?scope=drive)"
    - "Access tokens refresh automatically when expired without user re-authentication"
    - "Backend endpoint /api/auth/drive-status exposes whether user has Drive scopes"
    - "Existing login flow (without Drive scopes) still works for basic auth"
  artifacts:
    - path: "backend/app/auth/router.py"
      provides: "Extended OAuth flow with Drive scopes, token storage, drive-status endpoint"
      contains: "drive.file"
    - path: "backend/app/auth/token_refresh.py"
      provides: "Automatic token refresh logic"
      exports: ["get_valid_access_token"]
  key_links:
    - from: "backend/app/auth/router.py"
      to: "backend/app/auth/encryption.py"
      via: "encrypts tokens before storing in UserDB"
      pattern: "encrypt_token"
    - from: "backend/app/auth/router.py"
      to: "backend/app/db/models.py"
      via: "stores tokens in UserDB.google_access_token, google_refresh_token, token_expiry, drive_scopes"
      pattern: "google_access_token|google_refresh_token"
    - from: "backend/app/auth/token_refresh.py"
      to: "backend/app/auth/encryption.py"
      via: "decrypts refresh token, encrypts new access token after refresh"
      pattern: "decrypt_token|encrypt_token"
    - from: "backend/app/auth/token_refresh.py"
      to: "Google OAuth token endpoint"
      via: "POST to https://oauth2.googleapis.com/token with refresh_token grant"
      pattern: "oauth2.googleapis.com/token"
---

<objective>
Extend the OAuth flow to request Drive/Sheets scopes, store encrypted tokens in the database on callback, implement automatic token refresh, and add a drive-status endpoint for frontend scope detection.

Purpose: This wires the token storage foundation (Plan 01) to the actual OAuth flow, completing the token management lifecycle: acquire -> store (encrypted) -> refresh -> expose status.
Output: Working OAuth flow with Drive scopes, automatic token refresh, drive-status API endpoint.
</objective>

<execution_context>
@/Users/rgv250cc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rgv250cc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-token-management-foundation/01-01-SUMMARY.md
@backend/app/auth/router.py
@backend/app/auth/config.py
@backend/app/auth/deps.py
@backend/app/auth/encryption.py
@backend/app/db/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend OAuth flow with Drive scopes and token storage</name>
  <files>
    backend/app/auth/router.py
  </files>
  <action>
Modify `backend/app/auth/router.py` to support expanded OAuth scopes and store tokens in the database.

**Changes to `get_oauth()`:**
- Remove the global `_oauth` singleton pattern. Instead, keep it but make the registered scopes the BASE scopes only (`openid email profile`). The actual scope requested per-login will be controlled dynamically via the login endpoint (authlib supports passing scope at authorize_redirect time).

**Changes to `login()` endpoint:**
- Accept an optional query parameter `scope` (e.g., `/auth/login?scope=drive`).
- When `scope=drive`, expand the requested scopes to include `https://www.googleapis.com/auth/drive.file` and `https://www.googleapis.com/auth/spreadsheets`.
- When `scope=drive`, also add `access_type=offline` and `prompt=consent` to the authorize_redirect call to ensure a refresh token is returned. Use authlib's `authorize_redirect()` kwargs to pass these as extra authorization parameters.
- When no `scope` param (default login), keep existing behavior with just `openid email profile`.
- Store the requested scope mode in `request.session["oauth_scope_mode"]` so the callback knows what was requested.

**Changes to `callback()` endpoint:**
- After token exchange, extract and store:
  - `token['access_token']` -> encrypt via `encrypt_token()` -> `user.google_access_token`
  - `token.get('refresh_token')` -> encrypt via `encrypt_token()` -> `user.google_refresh_token` (only if present; refresh_token is only returned on first consent or when prompt=consent)
  - `token.get('expires_in', 3600)` -> compute expiry as `datetime.utcnow() + timedelta(seconds=expires_in)` -> `user.token_expiry`
  - `token.get('scope', '')` -> `user.drive_scopes` (the full scope string returned by Google)
- Import `encrypt_token` from `app.auth.encryption`.
- Import `datetime` and `timedelta` from standard library.
- If `refresh_token` is NOT in the token response (common when user previously authorized without `prompt=consent`), do NOT overwrite an existing `user.google_refresh_token` (preserve the old one).
- Clear `request.session.pop("oauth_scope_mode", None)` after processing.

**Add new endpoint `drive_status()`:**
- `@router.get("/drive-status")` — requires `get_current_user` dependency.
- Returns JSON: `{"connected": bool, "scopes": list[str]}`.
- `connected` is `True` if `user.drive_scopes` contains both `drive.file` and `spreadsheets`.
- `scopes` is the list of granted scopes (split from `user.drive_scopes`).
- If user has no `drive_scopes`, return `{"connected": false, "scopes": []}`.

**Update `/auth/me` endpoint:**
- Add `driveConnected: bool` to the response payload (check `user.drive_scopes` for Drive scope presence). This allows the frontend to detect Drive availability without a separate API call.

**Important:** Do NOT break the existing login flow. A user hitting `/auth/login` with no query params must still get the standard `openid email profile` flow and be logged in successfully. Token storage is additive — if no tokens returned in basic flow, columns remain NULL.
  </action>
  <verify>
    - `python -c "from app.auth.router import router; routes = [r.path for r in router.routes]; assert '/drive-status' in routes; print('drive-status endpoint exists')"` (from backend/)
    - Manually test: Start app, visit `/api/auth/login` — redirects to Google consent with basic scopes (no Drive)
    - Manually test: Visit `/api/auth/login?scope=drive` — redirects to Google consent with Drive scopes included
    - After callback: verify `user.google_access_token` is NOT NULL and is encrypted (not plaintext)
    - After callback: verify `user.drive_scopes` contains "drive.file" and "spreadsheets" (for Drive login)
    - `/api/auth/drive-status` returns `{"connected": true, "scopes": [...]}` for user with Drive scopes
    - `/api/auth/drive-status` returns `{"connected": false, "scopes": []}` for user without Drive scopes
    - `/api/auth/me` includes `driveConnected` field
  </verify>
  <done>
    - Standard login flow still works (no regression)
    - Drive login flow requests expanded scopes with offline access
    - Callback stores encrypted access_token, refresh_token, token_expiry, drive_scopes in UserDB
    - drive-status endpoint correctly reports scope status
    - /auth/me includes driveConnected boolean
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement automatic token refresh logic</name>
  <files>
    backend/app/auth/token_refresh.py
  </files>
  <action>
Create `backend/app/auth/token_refresh.py` with an `async def get_valid_access_token(user: UserDB, db: AsyncSession) -> str` function that:

1. **Checks if user has Drive tokens**: If `user.google_access_token` is None, raise `ValueError("User has not connected Google Drive")`.

2. **Checks token expiry**: If `user.token_expiry` is not None and `datetime.utcnow() < user.token_expiry - timedelta(minutes=5)` (5-minute buffer), decrypt and return the current access token via `decrypt_token(user.google_access_token)`.

3. **Refreshes if expired or close to expiry**:
   - If `user.google_refresh_token` is None, raise `HTTPException(status_code=401, detail="drive_reconnect_required")` — user needs to re-authenticate with Drive scopes.
   - Decrypt the refresh token via `decrypt_token(user.google_refresh_token)`.
   - Make an HTTP POST to `https://oauth2.googleapis.com/token` with:
     - `client_id` from `os.environ.get("GOOGLE_CLIENT_ID")`
     - `client_secret` from `os.environ.get("GOOGLE_CLIENT_SECRET")`
     - `refresh_token` (decrypted)
     - `grant_type=refresh_token`
   - Use `httpx.AsyncClient()` for the HTTP call (httpx is already in requirements.txt).
   - Parse JSON response. If `response.status_code != 200`, check for `invalid_grant` error (refresh token revoked) and raise `HTTPException(401, detail="drive_reconnect_required")`. For other errors, raise `HTTPException(502, detail="Token refresh failed")`.
   - Extract new `access_token` and `expires_in` from response.
   - Encrypt the new access token and update `user.google_access_token`.
   - Update `user.token_expiry` to `datetime.utcnow() + timedelta(seconds=expires_in)`.
   - Note: Google does NOT return a new refresh_token on refresh — keep the existing one.
   - `await db.commit()` to persist the updated token.
   - Return the new (plaintext) access token.

4. **Error handling**:
   - Catch `ValueError` from `decrypt_token` (encryption key changed) — raise `HTTPException(401, detail="drive_reconnect_required")` with a log warning.
   - Log token refresh events at INFO level: `"Refreshed Drive access token for user {user.id}"`.
   - Log refresh failures at ERROR level.

Import typing, datetime, httpx, logging, and the necessary app modules. Follow existing conventions (snake_case, docstrings, logger = `logging.getLogger("uvicorn.error")`).
  </action>
  <verify>
    - `python -c "from app.auth.token_refresh import get_valid_access_token; print('Import OK')"` (from backend/)
    - Function signature accepts (UserDB, AsyncSession) and returns str
    - Unit test (conceptual): mock httpx.post to return new token, verify user.google_access_token is updated in DB
    - Verify: when token_expiry is in the future, function returns decrypted token WITHOUT making HTTP call
    - Verify: when token_expiry is in the past, function calls Google token endpoint
    - Verify: when refresh_token is None, raises 401 with "drive_reconnect_required"
  </verify>
  <done>
    - get_valid_access_token returns valid access token (plaintext) for Drive API calls
    - Expired tokens are automatically refreshed via Google's token endpoint
    - Refreshed tokens are encrypted and persisted in database
    - Revoked refresh tokens trigger 401 with "drive_reconnect_required" detail
    - 5-minute buffer prevents mid-request token expiry
    - Missing tokens or encryption errors produce clear error messages
  </done>
</task>

</tasks>

<verification>
1. App starts successfully with new code (no import errors, no startup crashes)
2. Existing login flow works unchanged (visit /auth/login, complete OAuth, session created)
3. Drive login flow works (visit /auth/login?scope=drive, consent screen shows Drive scopes)
4. After Drive login: UserDB has encrypted tokens and scopes stored
5. /api/auth/drive-status returns correct connected/disconnected state
6. /api/auth/me includes driveConnected field
7. Token refresh module imports and has correct function signature
8. Token refresh handles expired tokens, missing refresh tokens, and revoked tokens
</verification>

<success_criteria>
- Existing users can log in normally (no regression)
- New Drive login stores encrypted tokens in database
- drive-status endpoint correctly detects Drive scope availability
- Token refresh logic exists and handles all edge cases (expired, revoked, missing)
- All three AUTH requirements (AUTH-01, AUTH-02, AUTH-03) are implemented
</success_criteria>

<output>
After completion, create `.planning/phases/01-token-management-foundation/01-02-SUMMARY.md`
</output>
