---
phase: 04-frontend-picker-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/types/index.ts
  - frontend/src/lib/api.ts
  - frontend/src/context/AuthContext.tsx
  - frontend/src/hooks/useDriveFilePicker.ts
  - frontend/src/components/WorkflowWizard/DriveFilePicker.tsx
autonomous: true
user_setup:
  - service: google-picker-api
    why: "Google Picker requires a browser API key (separate from OAuth client ID)"
    env_vars:
      - name: VITE_GOOGLE_CLIENT_ID
        source: "Same value as GOOGLE_CLIENT_ID already in backend .env. Copy it to frontend .env"
      - name: VITE_GOOGLE_API_KEY
        source: "Google Cloud Console -> APIs & Services -> Credentials -> Create API Key. Restrict to HTTP referrers (localhost:5173/*, your-domain/*) and Google Picker API only."
    dashboard_config:
      - task: "Enable Google Picker API"
        location: "Google Cloud Console -> APIs & Services -> Library -> Search 'Google Picker API' -> Enable"
      - task: "Restrict API key"
        location: "Google Cloud Console -> APIs & Services -> Credentials -> Edit API key -> Application restrictions: HTTP referrers -> API restrictions: Google Picker API"

must_haves:
  truths:
    - "AuthUser type includes driveConnected boolean from /auth/me response"
    - "FileDefinition supports both local and Drive file sources via source field"
    - "Frontend can fetch valid access token from /api/auth/token"
    - "Frontend can call /api/drive/download to parse a Drive file by ID"
    - "useDriveFilePicker hook opens Google Picker and returns selected file metadata"
  artifacts:
    - path: "frontend/src/types/index.ts"
      provides: "Extended FileDefinition with source, driveFileId, driveMimeType, driveModifiedTime fields"
      contains: "source.*local.*drive"
    - path: "frontend/src/lib/api.ts"
      provides: "driveApi object with getToken and downloadFile functions"
      contains: "driveApi"
    - path: "frontend/src/context/AuthContext.tsx"
      provides: "driveConnected field in AuthUser and AuthState"
      contains: "driveConnected"
    - path: "frontend/src/hooks/useDriveFilePicker.ts"
      provides: "Custom hook wrapping react-google-drive-picker with token fetching"
      contains: "useDriveFilePicker"
    - path: "frontend/src/components/WorkflowWizard/DriveFilePicker.tsx"
      provides: "Button component that opens Google Picker and calls onSelect callback"
      contains: "DriveFilePicker"
  key_links:
    - from: "frontend/src/hooks/useDriveFilePicker.ts"
      to: "/api/auth/token"
      via: "driveApi.getToken() call"
      pattern: "driveApi\\.getToken|api/auth/token"
    - from: "frontend/src/hooks/useDriveFilePicker.ts"
      to: "react-google-drive-picker"
      via: "useDrivePicker hook import"
      pattern: "useDrivePicker|react-google-drive-picker"
    - from: "frontend/src/context/AuthContext.tsx"
      to: "/api/auth/me"
      via: "driveConnected from me response"
      pattern: "driveConnected"
---

<objective>
Create the foundational frontend infrastructure for Google Drive file selection: extended types supporting dual file sources, Drive API client functions, auth context with Drive status, and the Google Picker hook + component.

Purpose: This plan builds all the reusable pieces that Plan 02 will wire into the existing FilesStep. Separating foundation from integration keeps each plan focused.
Output: Extended types, API functions, auth context with driveConnected, useDriveFilePicker hook, and DriveFilePicker component.
</objective>

<execution_context>
@/Users/rgv250cc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rgv250cc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-frontend-picker-ui/04-RESEARCH.md
@frontend/src/types/index.ts
@frontend/src/lib/api.ts
@frontend/src/context/AuthContext.tsx
@frontend/package.json
@backend/app/api/drive.py
@backend/app/auth/router.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install picker package, extend types, add Drive API functions, update auth context</name>
  <files>
    frontend/package.json
    frontend/src/types/index.ts
    frontend/src/lib/api.ts
    frontend/src/context/AuthContext.tsx
  </files>
  <action>
**Step 1: Install package.**

Run from `frontend/` directory:
```
npm install react-google-drive-picker
```

Note: Do NOT install `@types/google.picker` -- `react-google-drive-picker` includes its own types and the separate types package causes conflicts.

**Step 2: Extend FileDefinition in `frontend/src/types/index.ts`.**

Add a `source` field and Drive metadata fields to the existing `FileDefinition` interface. Keep full backward compatibility -- existing local files work unchanged.

Add these fields to `FileDefinition` (after `headerRow`):
```typescript
  // File source type
  source?: 'local' | 'drive'  // Optional for backward compat, defaults to 'local'

  // Drive file metadata (only present when source === 'drive')
  driveFileId?: string        // Google Drive file ID
  driveMimeType?: string      // MIME type from Drive (e.g., 'application/vnd.google-apps.spreadsheet')
  driveModifiedTime?: string  // ISO 8601 timestamp of last modification
```

Make `source` optional (not required) so existing code creating FileDefinition objects without it continues to work. When absent, treat as 'local'.

Also add a `DrivePickerFile` interface for Picker callback data:
```typescript
/** Metadata returned from Google Picker when user selects a file */
export interface DrivePickerFile {
  id: string
  name: string
  mimeType: string
  lastEditedUtc?: number
  sizeBytes?: number
}
```

Also add a `DriveFileResponse` interface matching the backend response shape (use camelCase to match frontend conventions, the backend returns snake_case but fetchJSON does NOT auto-convert -- so use snake_case field names to match raw JSON):
```typescript
/** Response from /api/drive/download and /api/drive/read endpoints */
export interface DriveFileResponse {
  success: boolean
  file_metadata: {
    id: string
    name: string
    mime_type: string
    modified_time: string
    owner: string
    web_view_link: string
    size?: number
  }
  row_count: number
  columns: string[]
  sample_data: Record<string, unknown>[]
}
```

**Step 3: Add Drive API functions to `frontend/src/lib/api.ts`.**

Add a `driveApi` export object with these functions:

```typescript
// Drive API
export const driveApi = {
  /** Fetch valid Google access token for Picker initialization */
  getToken: async (): Promise<{ access_token: string; expires_at: string | null }> => {
    const response = await fetch(`${API_BASE}/auth/token`, {
      ...defaultFetchOptions,
    })
    if (!response.ok) {
      const error = await response.json().catch(() => ({ detail: 'Not authenticated' }))
      throw new Error(error.detail || `HTTP ${response.status}`)
    }
    return response.json()
  },

  /** Download and parse a Drive file by ID */
  downloadFile: (fileId: string) =>
    fetchJSON<DriveFileResponse>('/drive/download', {
      method: 'POST',
      body: JSON.stringify({ file_id: fileId }),
    }),

  /** Read a Google Sheet by spreadsheet ID */
  readSheet: (spreadsheetId: string, rangeName?: string) =>
    fetchJSON<DriveFileResponse>('/drive/read', {
      method: 'POST',
      body: JSON.stringify({
        spreadsheet_id: spreadsheetId,
        range_name: rangeName,
      }),
    }),
}
```

Import `DriveFileResponse` from types at the top of the file.

**Step 4: Update AuthUser and AuthContext.**

In `frontend/src/lib/api.ts`, add `driveConnected` to the `AuthUser` interface:
```typescript
export interface AuthUser {
  id: string
  email: string
  name: string | null
  avatarUrl: string | null
  driveConnected: boolean  // NEW: whether user has Drive scopes
}
```

The backend `/auth/me` already returns `driveConnected: boolean` -- no backend changes needed.

In `frontend/src/context/AuthContext.tsx`, the existing `useAuth()` hook already exposes the full `AuthUser` object via `user` property. Since `driveConnected` is added to `AuthUser`, it flows through automatically. No changes needed to AuthContext.tsx beyond the type already being updated in api.ts.

However, add a convenience property to the auth state for cleaner access:
```typescript
type AuthState = {
  user: AuthUser | null
  loading: boolean
  driveConnected: boolean  // NEW: convenience accessor
  login: () => void
  loginWithDrive: () => void  // NEW: login requesting Drive scopes
  logout: () => Promise<void>
}
```

Add the `loginWithDrive` function:
```typescript
const loginWithDrive = useCallback(() => {
  window.location.href = authApi.loginUrl() + '?scope=drive'
}, [])
```

And set `driveConnected` in the provider value:
```typescript
driveConnected: user?.driveConnected ?? false
```

Update the `authApi.loginUrl` to remain a function that returns the base URL (no changes needed there, the `?scope=drive` is appended in `loginWithDrive`).
  </action>
  <verify>
1. Run `cd frontend && npm ls react-google-drive-picker` -- package is listed
2. Run `cd frontend && npx tsc --noEmit` -- no TypeScript errors
3. Verify `DrivePickerFile`, `DriveFileResponse` types exist in types/index.ts
4. Verify `driveApi` export exists in api.ts
5. Verify `driveConnected` and `loginWithDrive` are in AuthContext
  </verify>
  <done>
- react-google-drive-picker installed in package.json
- FileDefinition extended with source, driveFileId, driveMimeType, driveModifiedTime
- DrivePickerFile and DriveFileResponse types defined
- driveApi with getToken, downloadFile, readSheet functions added to api.ts
- AuthUser includes driveConnected boolean
- AuthContext exposes driveConnected convenience accessor and loginWithDrive function
- TypeScript compiles with zero errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useDriveFilePicker hook and DriveFilePicker component</name>
  <files>
    frontend/src/hooks/useDriveFilePicker.ts
    frontend/src/components/WorkflowWizard/DriveFilePicker.tsx
  </files>
  <action>
**Step 1: Create `frontend/src/hooks/useDriveFilePicker.ts`.**

This custom hook wraps `react-google-drive-picker` with our backend token fetching.

```typescript
import { useCallback, useState } from 'react'
import useDrivePicker from 'react-google-drive-picker'
import { driveApi } from '../lib/api'
import type { DrivePickerFile } from '../types'

interface UseDriveFilePickerOptions {
  onSelect: (file: DrivePickerFile) => void
  onError?: (error: string) => void
}

export function useDriveFilePicker({ onSelect, onError }: UseDriveFilePickerOptions) {
  const [openPicker] = useDrivePicker()
  const [isLoading, setIsLoading] = useState(false)

  const handleOpenPicker = useCallback(async () => {
    setIsLoading(true)
    try {
      // Fetch fresh token from backend (handles refresh automatically)
      const tokenData = await driveApi.getToken()

      openPicker({
        clientId: import.meta.env.VITE_GOOGLE_CLIENT_ID,
        developerKey: import.meta.env.VITE_GOOGLE_API_KEY,
        token: tokenData.access_token,
        viewId: 'DOCS',
        supportDrives: true,     // Enable Shared Drives (SELECT-03)
        multiselect: false,
        showUploadView: false,
        showUploadFolders: false,
        callbackFunction: (data) => {
          if (data.action === 'picked' && data.docs?.length > 0) {
            const doc = data.docs[0]
            onSelect({
              id: doc.id,
              name: doc.name,
              mimeType: doc.mimeType,
              lastEditedUtc: doc.lastEditedUtc,
              sizeBytes: doc.sizeBytes,
            })
          }
          // data.action === 'cancel' -> user closed picker, no-op
        },
      })
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to open Drive picker'
      onError?.(message)
    } finally {
      setIsLoading(false)
    }
  }, [openPicker, onSelect, onError])

  return {
    openPicker: handleOpenPicker,
    isLoading,
  }
}
```

Key decisions:
- Token fetched on-demand each time picker opens (not cached in frontend -- backend handles caching/refresh)
- `supportDrives: true` enables Shared Drives per SELECT-03
- `viewId: 'DOCS'` shows all file types (user can see Sheets, Excel, CSV)
- `multiselect: false` -- one file at a time to match current workflow UX
- No `viewMimeTypes` filter -- let user see all files, backend validates on download

**Step 2: Create `frontend/src/components/WorkflowWizard/DriveFilePicker.tsx`.**

This is a button component that opens the picker and handles the full flow: open picker -> select file -> call backend to parse -> return FileDefinition-compatible data.

```typescript
import { useCallback, useState } from 'react'
import { Cloud, Loader2 } from 'lucide-react'
import { useDriveFilePicker } from '../../hooks/useDriveFilePicker'
import { driveApi } from '../../lib/api'
import type { DrivePickerFile, ColumnInfo } from '../../types'

interface DriveFilePickerProps {
  onFileReady: (params: {
    name: string
    filename: string
    columns: ColumnInfo[]
    sampleData?: Record<string, unknown>[]
    driveFileId: string
    driveMimeType: string
    driveModifiedTime?: string
  }) => void
  onError?: (error: string) => void
  disabled?: boolean
}

export function DriveFilePicker({ onFileReady, onError, disabled }: DriveFilePickerProps) {
  const [isParsing, setIsParsing] = useState(false)

  const handleFileSelected = useCallback(async (pickerFile: DrivePickerFile) => {
    setIsParsing(true)
    try {
      // Call backend to download and parse the Drive file
      const result = await driveApi.downloadFile(pickerFile.id)

      // Convert backend column strings to ColumnInfo objects
      // Backend returns plain column name strings + sample_data rows
      const columns: ColumnInfo[] = result.columns.map((colName) => {
        // Infer type from sample data
        const sampleValues = result.sample_data
          .slice(0, 3)
          .map((row) => row[colName] as string | number | null)

        return {
          name: colName,
          type: 'text' as const, // Default to text; backend doesn't return types
          sampleValues,
        }
      })

      onFileReady({
        name: result.file_metadata.name.replace(/\.[^/.]+$/, ''),
        filename: result.file_metadata.name,
        columns,
        sampleData: result.sample_data,
        driveFileId: pickerFile.id,
        driveMimeType: pickerFile.mimeType,
        driveModifiedTime: pickerFile.lastEditedUtc
          ? new Date(pickerFile.lastEditedUtc).toISOString()
          : result.file_metadata.modified_time,
      })
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to load Drive file'
      onError?.(message)
    } finally {
      setIsParsing(false)
    }
  }, [onFileReady, onError])

  const { openPicker, isLoading: isPickerLoading } = useDriveFilePicker({
    onSelect: handleFileSelected,
    onError,
  })

  const isLoading = isPickerLoading || isParsing

  return (
    <button
      onClick={openPicker}
      disabled={disabled || isLoading}
      className="flex flex-col items-center gap-3 p-6 border-2 border-slate-300 rounded-lg hover:border-blue-500 hover:bg-blue-50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed w-full"
    >
      {isLoading ? (
        <Loader2 className="w-8 h-8 text-blue-600 animate-spin" />
      ) : (
        <Cloud className="w-8 h-8 text-blue-600" />
      )}
      <div>
        <div className="font-medium text-slate-900">
          {isParsing ? 'Loading file...' : isPickerLoading ? 'Opening Drive...' : 'Select from Google Drive'}
        </div>
        <div className="text-sm text-slate-500">
          Browse My Drive and Shared Drives
        </div>
      </div>
    </button>
  )
}
```

Key decisions:
- Two loading states: `isPickerLoading` (opening picker) and `isParsing` (downloading/parsing file after selection)
- Backend `/api/drive/download` does the heavy lifting -- converts to columns + sample_data
- Column type defaults to 'text' since backend returns raw column names (not typed like the local parser)
- Name derived from file metadata, stripping extension (matching local upload pattern)
- Uses lucide-react icons (already in project), no new icon library
  </action>
  <verify>
1. Run `cd frontend && npx tsc --noEmit` -- zero TypeScript errors
2. Verify `frontend/src/hooks/useDriveFilePicker.ts` exists and exports `useDriveFilePicker`
3. Verify `frontend/src/components/WorkflowWizard/DriveFilePicker.tsx` exists and exports `DriveFilePicker`
4. Verify no import errors (all referenced modules exist)
  </verify>
  <done>
- useDriveFilePicker hook created with token fetching and Google Picker integration
- DriveFilePicker component created with loading states and backend file parsing
- Shared Drives enabled via supportDrives: true (SELECT-03)
- TypeScript compiles with zero errors
- Both files follow project conventions (named exports, PascalCase components, camelCase hooks)
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && npx tsc --noEmit` -- TypeScript compilation passes
2. `cd frontend && npm run build` -- Vite build succeeds (catches any import/export issues)
3. All new types (DrivePickerFile, DriveFileResponse) importable from types/index.ts
4. driveApi functions are exported from api.ts
5. AuthContext provides driveConnected and loginWithDrive
6. DriveFilePicker component renders without errors
</verification>

<success_criteria>
- react-google-drive-picker package installed
- FileDefinition extended with Drive fields (backward compatible)
- driveApi with getToken/downloadFile/readSheet in api.ts
- AuthContext exposes driveConnected + loginWithDrive
- useDriveFilePicker hook handles token fetch + picker opening
- DriveFilePicker component handles full flow (pick -> parse -> callback)
- All TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/04-frontend-picker-ui/04-01-SUMMARY.md`
</output>
