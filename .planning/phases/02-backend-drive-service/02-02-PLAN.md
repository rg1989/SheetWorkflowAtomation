---
phase: 02-backend-drive-service
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - backend/app/services/sheets.py
  - backend/app/services/drive.py
autonomous: true

must_haves:
  truths:
    - "Backend can read Google Sheets natively via Sheets API and return a pandas DataFrame"
    - "Empty sheets return an empty DataFrame without errors"
    - "Sheets with only headers (no data rows) return an empty DataFrame"
    - "The first row of the sheet is used as column headers"
    - "Sheets API errors (403, 404, 429) return user-friendly messages"
    - "download_drive_file_to_df routes Google Sheets to native Sheets API read (not export)"
  artifacts:
    - path: "backend/app/services/sheets.py"
      provides: "Native Google Sheets reading via Sheets API v4"
      exports: ["read_sheet_to_df", "get_sheet_tabs"]
  key_links:
    - from: "backend/app/services/sheets.py"
      to: "backend/app/services/google_auth.py"
      via: "build_sheets_service() call"
      pattern: "build_sheets_service"
    - from: "backend/app/services/drive.py"
      to: "backend/app/services/sheets.py"
      via: "download_drive_file_to_df routes MIME_GOOGLE_SHEET to read_sheet_to_df"
      pattern: "read_sheet_to_df"
---

<objective>
Create the Sheets API service for native Google Sheets reading, which is more efficient than the Drive export approach for reading spreadsheet data.

Purpose: Google Sheets files are best read via the Sheets API (preserves data, handles large sheets better than 10MB export limit, provides sheet tab metadata). This plan creates the native read path and updates drive.py to prefer it for Google Sheets files.

Output: `backend/app/services/sheets.py` (Sheets API read + tab listing), updated `backend/app/services/drive.py` (route Google Sheets to native Sheets API instead of export).
</objective>

<execution_context>
@/Users/rgv250cc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rgv250cc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-backend-drive-service/02-RESEARCH.md
@.planning/phases/02-backend-drive-service/02-01-SUMMARY.md
@backend/app/services/google_auth.py
@backend/app/services/drive.py
@backend/app/db/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Sheets API service for native spreadsheet reading</name>
  <files>backend/app/services/sheets.py</files>
  <action>
    Create `backend/app/services/sheets.py` with:

    ```python
    """
    Google Sheets API service.

    Reads Google Sheets natively via Sheets API v4, converting
    spreadsheet data to pandas DataFrames. More efficient than
    Drive export for reading cell values.
    """
    ```

    **Import the retry decorator from drive.py:**
    - Import `drive_retry` from `app.services.drive` (reuse the same tenacity config)
    - Import `_handle_drive_error` from `app.services.drive` (reuse error mapping -- rename in drive.py to `handle_google_api_error` and make it public if needed, OR import the private function since it's within the same package)
    - Actually, to keep things clean: create a shared `_handle_sheets_error` in sheets.py that follows the same pattern as drive.py's error handler but with Sheets-specific messages. The error mapping is identical (403, 404, 429) so consider extracting to a shared utility. **Simplest approach:** import `_handle_drive_error` directly since it's the same package and the error handling is identical for both APIs.

    **`async def get_sheet_tabs(sheets_service, spreadsheet_id: str) -> list[dict]`:**
    - Call `sheets_service.spreadsheets().get(spreadsheetId=spreadsheet_id, fields="sheets.properties").execute()` via `asyncio.to_thread()`
    - Extract sheet properties: `[{"title": s["properties"]["title"], "index": s["properties"]["index"], "sheetId": s["properties"]["sheetId"]} for s in result.get("sheets", [])]`
    - Wrap in try/except HttpError, call error handler on failure
    - Apply `@drive_retry` decorator
    - Return list of tab info dicts

    **`async def read_sheet_to_df(sheets_service, spreadsheet_id: str, range_name: str = "") -> pd.DataFrame`:**
    - If `range_name` is empty string, default to reading the first sheet (get tabs first, use first tab title)
    - Call `sheets_service.spreadsheets().values().get(spreadsheetId=spreadsheet_id, range=range_name).execute()` via `asyncio.to_thread()`
    - Extract values: `result.get("values", [])`
    - Handle edge cases:
      - Empty `values` list (no data at all): return `pd.DataFrame()`
      - Single row (headers only, no data): return `pd.DataFrame(columns=values[0])` -- DataFrame with column names but no rows
      - Normal case: `pd.DataFrame(values[1:], columns=values[0])`
    - Handle ragged rows: Sheets API may return rows with fewer values than headers. Pad short rows with None before creating DataFrame. Use: `max_cols = len(values[0]); padded = [row + [None] * (max_cols - len(row)) for row in values[1:]]`
    - Strip whitespace from column names for consistency with ExcelParser
    - Wrap in try/except HttpError, call error handler on failure
    - Apply `@drive_retry` decorator
    - Log at INFO level: "Reading Google Sheet {spreadsheet_id} range={range_name}"
    - Return DataFrame

    **Important implementation notes:**
    - All `.execute()` calls must be wrapped in `asyncio.to_thread()` since google-api-python-client is synchronous
    - Use `logging.getLogger("uvicorn.error")` consistent with project convention
  </action>
  <verify>
    Run: `python -c "from app.services.sheets import read_sheet_to_df, get_sheet_tabs; print('imports ok')"` from backend/ dir succeeds.
    Run: `python -c "import pandas as pd; from app.services.sheets import read_sheet_to_df; print('pandas integration ok')"` succeeds.
  </verify>
  <done>
    sheets.py reads Google Sheets natively via Sheets API v4. read_sheet_to_df returns pandas DataFrame with first row as headers. Empty sheets and header-only sheets return empty DataFrames without errors. Ragged rows are padded with None. Retry logic and error handling match drive.py patterns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Drive service to route Google Sheets to native Sheets API</name>
  <files>backend/app/services/drive.py</files>
  <action>
    Update `download_drive_file_to_df` in `backend/app/services/drive.py`:

    1. Change the Google Sheets routing in `download_drive_file_to_df`:
       - OLD: `MIME_GOOGLE_SHEET` -> `_export_google_sheet_to_df(service, file_id)` (export as Excel)
       - NEW: `MIME_GOOGLE_SHEET` -> `read_sheet_to_df(sheets_service, file_id)` (native Sheets API)

    2. Update the function signature to accept an optional `sheets_service` parameter:
       ```python
       async def download_drive_file_to_df(
           service,
           file_id: str,
           mime_type: str | None = None,
           sheets_service=None,
       ) -> pd.DataFrame:
       ```

    3. When `mime_type == MIME_GOOGLE_SHEET`:
       - If `sheets_service` is provided: use `read_sheet_to_df(sheets_service, file_id)` from sheets.py
       - If `sheets_service` is None: fall back to `_export_google_sheet_to_df(service, file_id)` (export approach still works as fallback)
       - Import `read_sheet_to_df` from `app.services.sheets`

    4. Keep `_export_google_sheet_to_df` as a private fallback (don't delete it). This ensures the function works even if only a Drive service is available.

    5. Add a docstring note explaining the routing:
       ```
       For Google Sheets: prefers native Sheets API read (if sheets_service provided)
       with fallback to Drive export-as-Excel approach.
       ```

    This design means callers that have both services get the efficient native read, while callers with only the Drive service still work via export.
  </action>
  <verify>
    Run: `python -c "from app.services.drive import download_drive_file_to_df; import inspect; sig = inspect.signature(download_drive_file_to_df); assert 'sheets_service' in sig.parameters; print('signature updated')"` from backend/ dir.
    Run: `python -c "from app.services.drive import MIME_GOOGLE_SHEET; from app.services.sheets import read_sheet_to_df; print('cross-module imports ok')"` from backend/ dir.
  </verify>
  <done>
    download_drive_file_to_df routes Google Sheets to native Sheets API read when sheets_service is provided, falling back to Drive export when it is not. The function supports all three file types (Excel, CSV, Google Sheets) through a single entry point. Both services modules (drive.py, sheets.py) share retry and error handling patterns.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from app.services.sheets import read_sheet_to_df, get_sheet_tabs"` succeeds
2. `python -c "from app.services.drive import download_drive_file_to_df; import inspect; print(inspect.signature(download_drive_file_to_df))"` shows sheets_service parameter
3. sheets.py handles empty sheets (returns empty DataFrame)
4. sheets.py handles header-only sheets (returns DataFrame with columns, no rows)
5. sheets.py handles ragged rows (pads with None)
6. sheets.py uses asyncio.to_thread() for all .execute() calls
7. sheets.py applies drive_retry decorator for 429/5xx retries
8. drive.py routes MIME_GOOGLE_SHEET to read_sheet_to_df when sheets_service is available
9. drive.py falls back to _export_google_sheet_to_df when sheets_service is None
</verification>

<success_criteria>
- read_sheet_to_df() reads Google Sheets via Sheets API v4 and returns pandas DataFrame
- get_sheet_tabs() returns list of sheet tab names and metadata
- Empty sheets and header-only sheets handled gracefully (no IndexError)
- Ragged rows padded with None (no DataFrame construction errors)
- download_drive_file_to_df() prefers native Sheets API for Google Sheets when available
- All Phase 2 success criteria met: Excel, CSV, Google Sheets -> DataFrame with error handling
</success_criteria>

<output>
After completion, create `.planning/phases/02-backend-drive-service/02-02-SUMMARY.md`
</output>
