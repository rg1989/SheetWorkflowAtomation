---
phase: 02-backend-drive-service
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/requirements.txt
  - backend/app/services/__init__.py
  - backend/app/services/google_auth.py
  - backend/app/services/drive.py
autonomous: true

must_haves:
  truths:
    - "Backend can build Google API credentials from stored encrypted tokens"
    - "Backend can download an Excel file from Drive by file ID and return a pandas DataFrame"
    - "Backend can download a CSV file from Drive by file ID and return a pandas DataFrame"
    - "API rate limit errors (HTTP 429) trigger exponential backoff with up to 5 retries"
    - "Permission errors (HTTP 403) return clear user-friendly messages"
    - "File-not-found errors (HTTP 404) return clear user-friendly messages"
  artifacts:
    - path: "backend/app/services/google_auth.py"
      provides: "Credential builder from stored tokens"
      exports: ["build_drive_service", "build_sheets_service"]
    - path: "backend/app/services/drive.py"
      provides: "Drive file download and DataFrame parsing"
      exports: ["download_drive_file_to_df", "get_drive_file_metadata"]
  key_links:
    - from: "backend/app/services/google_auth.py"
      to: "backend/app/auth/token_refresh.py"
      via: "get_valid_access_token() call"
      pattern: "get_valid_access_token"
    - from: "backend/app/services/google_auth.py"
      to: "backend/app/auth/encryption.py"
      via: "decrypt_token() for refresh token"
      pattern: "decrypt_token"
    - from: "backend/app/services/drive.py"
      to: "backend/app/services/google_auth.py"
      via: "build_drive_service() to get service object"
      pattern: "build_drive_service"
---

<objective>
Create the credential builder and Drive file download service that converts Google Drive files (Excel, CSV) to pandas DataFrames with proper error handling and retry logic.

Purpose: This is the foundation for all Google API interactions. Phase 1 stored encrypted tokens; this plan uses those tokens to build authenticated API service objects and download files from Drive. Error handling with exponential backoff ensures resilient API usage.

Output: `backend/app/services/google_auth.py` (credential/service builder), `backend/app/services/drive.py` (Drive download + parse), updated `backend/requirements.txt` with google-api-python-client and tenacity.
</objective>

<execution_context>
@/Users/rgv250cc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rgv250cc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-backend-drive-service/02-RESEARCH.md
@.planning/phases/01-token-management-foundation/01-01-SUMMARY.md
@.planning/phases/01-token-management-foundation/01-02-SUMMARY.md
@backend/app/auth/token_refresh.py
@backend/app/auth/encryption.py
@backend/app/auth/deps.py
@backend/app/db/models.py
@backend/app/core/parser.py
@backend/requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Google API dependencies and create credential builder</name>
  <files>
    backend/requirements.txt
    backend/app/services/__init__.py
    backend/app/services/google_auth.py
  </files>
  <action>
    1. Add to `backend/requirements.txt`:
       ```
       # Google API client
       google-api-python-client>=2.100.0
       google-auth>=2.20.0
       google-auth-oauthlib>=1.0.0

       # Retry logic
       tenacity>=8.2.0
       ```

    2. Create `backend/app/services/__init__.py` (empty file).

    3. Create `backend/app/services/google_auth.py` with:

       ```python
       """
       Build Google API service objects from stored OAuth tokens.

       Uses Phase 1's token storage and refresh logic to construct
       authenticated Drive v3 and Sheets v4 service objects.
       """
       ```

       Implement two async functions:

       **`async def build_drive_service(user: UserDB, db: AsyncSession)`:**
       - Call `get_valid_access_token(user, db)` from `app.auth.token_refresh` to get a valid (auto-refreshed) plaintext access token
       - Call `decrypt_token(user.google_refresh_token)` from `app.auth.encryption` to get plaintext refresh token
       - Build `google.oauth2.credentials.Credentials` object with:
         - `token=access_token`
         - `refresh_token=refresh_token`
         - `token_uri="https://oauth2.googleapis.com/token"`
         - `client_id=os.environ["GOOGLE_CLIENT_ID"]`
         - `client_secret=os.environ["GOOGLE_CLIENT_SECRET"]`
         - `scopes=user.drive_scopes.split() if user.drive_scopes else []`
       - Build and return `googleapiclient.discovery.build("drive", "v3", credentials=creds)`
       - Handle case where user has no Drive tokens: raise `ValueError("User has not connected Google Drive")`

       **`async def build_sheets_service(user: UserDB, db: AsyncSession)`:**
       - Same credential building as above (extract to internal `_build_credentials()` helper)
       - Build and return `googleapiclient.discovery.build("sheets", "v4", credentials=creds)`

       **Internal helper `async def _build_credentials(user, db) -> Credentials`:**
       - Shared logic for both service builders
       - Validates user has Drive tokens before proceeding

    4. Run `pip install -r backend/requirements.txt` to verify dependencies install cleanly.
  </action>
  <verify>
    Run: `cd backend && pip install -r requirements.txt` succeeds without errors.
    Run: `python -c "from app.services.google_auth import build_drive_service, build_sheets_service; print('imports ok')"` from backend/ dir succeeds.
  </verify>
  <done>
    google-api-python-client and tenacity installed. google_auth.py exports build_drive_service and build_sheets_service. Both functions use get_valid_access_token() for auto-refresh and decrypt_token() for refresh token access.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Drive file download service with error handling and retry</name>
  <files>backend/app/services/drive.py</files>
  <action>
    Create `backend/app/services/drive.py` with:

    ```python
    """
    Google Drive file download service.

    Downloads Excel and CSV files from Drive to pandas DataFrames.
    Handles Google Sheets files by exporting as Excel first.
    Includes retry logic for rate limits and user-friendly error messages.
    """
    ```

    **Constants:**
    - `MIME_EXCEL = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"`
    - `MIME_CSV = "text/csv"`
    - `MIME_GOOGLE_SHEET = "application/vnd.google-apps.spreadsheet"`
    - `DOWNLOADABLE_MIMES = {MIME_EXCEL, MIME_CSV}` (binary download via get_media)

    **Error handling function `_handle_drive_error(e: HttpError, file_id: str)`:**
    - Import `HttpError` from `googleapiclient.errors`
    - Import `HTTPException` from `fastapi`
    - Parse error body: `json.loads(e.content.decode("utf-8"))`
    - Map status codes to user-friendly messages:
      - 403: "Access denied to file {file_id}. Ensure the file is shared with you or request access from the owner."
      - 403 with "storageQuota" in reason: "Google Drive storage quota exceeded."
      - 404: "File not found. It may have been deleted or moved, or you may not have access."
      - 429: "Google Drive rate limit exceeded. Please wait a moment and try again."
      - Other: "Drive API error: {original_message}"
    - For 429 and 5xx (500, 502, 503, 504): re-raise the HttpError so tenacity can retry
    - For 403, 404, and other client errors: raise HTTPException immediately (no retry)

    **Retry decorator using tenacity:**
    ```python
    from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception

    def _is_retryable(exception):
        """Only retry on HttpError with 429 or 5xx status."""
        if isinstance(exception, HttpError):
            return exception.resp.status in (429, 500, 502, 503, 504)
        return False

    drive_retry = retry(
        retry=retry_if_exception(_is_retryable),
        wait=wait_exponential(multiplier=1, min=2, max=60),
        stop=stop_after_attempt(5),
        reraise=True,
    )
    ```

    **`async def get_drive_file_metadata(service, file_id: str) -> dict`:**
    - Call `service.files().get(fileId=file_id, fields="id,name,mimeType,modifiedTime,owners,webViewLink,size").execute()`
    - Wrap in try/except HttpError, call `_handle_drive_error` on failure
    - Return the metadata dict
    - Apply `@drive_retry` decorator

    **`async def download_drive_file_to_df(service, file_id: str, mime_type: str | None = None) -> pd.DataFrame`:**
    - If `mime_type` is None, call `get_drive_file_metadata` to get mimeType
    - Route based on MIME type:
      - `MIME_GOOGLE_SHEET`: call `_export_google_sheet_to_df(service, file_id)` (export as Excel, parse)
      - `MIME_EXCEL`: call `_download_binary_to_df(service, file_id, "excel")`
      - `MIME_CSV`: call `_download_binary_to_df(service, file_id, "csv")`
      - Other: raise `ValueError(f"Unsupported file type: {mime_type}. Supported: Google Sheets, Excel (.xlsx), CSV.")`

    **Internal `_download_binary_to_df(service, file_id: str, format: str) -> pd.DataFrame`:**
    - Apply `@drive_retry` decorator
    - Use `MediaIoBaseDownload` to download file content to `io.BytesIO()`
    - Wrap in try/except HttpError, call `_handle_drive_error` on failure
    - Parse based on format:
      - "excel": `pd.read_excel(buffer, engine="openpyxl")`
      - "csv": `pd.read_csv(buffer)`
    - Strip whitespace from column names (match existing ExcelParser behavior)
    - Return DataFrame

    **Internal `_export_google_sheet_to_df(service, file_id: str) -> pd.DataFrame`:**
    - Apply `@drive_retry` decorator
    - Use `service.files().export_media(fileId=file_id, mimeType=MIME_EXCEL)` to export Sheet as Excel
    - Download to `io.BytesIO()` via `MediaIoBaseDownload`
    - Parse with `pd.read_excel(buffer, engine="openpyxl")`
    - Strip whitespace from column names
    - Return DataFrame
    - Wrap in try/except HttpError, call `_handle_drive_error` on failure

    **Important implementation notes:**
    - All `service.xxx().execute()` calls are synchronous (google-api-python-client is sync). The async functions wrap these for consistency with the async FastAPI codebase. Use `await asyncio.to_thread()` to run blocking google API calls in a thread pool to avoid blocking the event loop.
    - Import `asyncio` and wrap all `.execute()` calls in `await asyncio.to_thread(lambda: service.files()...execute())`
    - Log operations at INFO level: "Downloading Drive file {file_id} ({mime_type})"
    - Log errors at WARNING level with file_id context
  </action>
  <verify>
    Run: `python -c "from app.services.drive import download_drive_file_to_df, get_drive_file_metadata; print('imports ok')"` from backend/ dir succeeds.
    Run: `python -c "from app.services.drive import MIME_EXCEL, MIME_CSV, MIME_GOOGLE_SHEET; print('constants ok')"` succeeds.
    Verify tenacity decorator is applied by checking: `python -c "from app.services.drive import _download_binary_to_df; print(hasattr(_download_binary_to_df, 'retry'))"` returns True.
  </verify>
  <done>
    drive.py can download Excel files from Drive to DataFrame, download CSV files from Drive to DataFrame, and export Google Sheets as Excel then parse to DataFrame. Rate limit errors (429) and server errors (5xx) trigger exponential backoff with up to 5 retries. Permission errors (403) immediately raise HTTPException with user-friendly message. File-not-found errors (404) raise HTTPException with clear message. All blocking Google API calls are wrapped in asyncio.to_thread to avoid blocking the FastAPI event loop.
  </done>
</task>

</tasks>

<verification>
1. `pip install -r backend/requirements.txt` completes without errors
2. `python -c "from app.services.google_auth import build_drive_service, build_sheets_service"` succeeds
3. `python -c "from app.services.drive import download_drive_file_to_df, get_drive_file_metadata"` succeeds
4. drive.py handles MIME type routing: Google Sheets -> export, Excel -> download, CSV -> download, other -> ValueError
5. drive.py has tenacity @drive_retry on all API-calling functions
6. drive.py error handler maps 403 -> user-friendly permission message, 404 -> file not found, 429 -> rate limit message
7. google_auth.py uses get_valid_access_token() from Phase 1 for auto-refresh
8. google_auth.py uses decrypt_token() from Phase 1 for refresh token decryption
9. All google-api-python-client .execute() calls wrapped in asyncio.to_thread()
</verification>

<success_criteria>
- google-api-python-client and tenacity are installed and importable
- build_drive_service() and build_sheets_service() construct authenticated service objects using Phase 1 tokens
- download_drive_file_to_df() handles Excel, CSV, and Google Sheets files and returns pandas DataFrames
- Error handling maps 403/404/429 to user-friendly HTTPException messages
- Retry logic uses exponential backoff (2s-60s, 5 attempts) for 429 and 5xx errors
- Blocking Google API calls run in thread pool via asyncio.to_thread()
</success_criteria>

<output>
After completion, create `.planning/phases/02-backend-drive-service/02-01-SUMMARY.md`
</output>
